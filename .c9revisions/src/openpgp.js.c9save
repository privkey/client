{"ts":1361901726316,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// GPG4Browsers - An OpenPGP implementation in javascript\n// Copyright (C) 2011 Recurity Labs GmbH\n// \n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n// \n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n// \n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n/**\n * @fileoverview The openpgp base class should provide all of the functionality \n * to consume the openpgp.js library. All additional classes are documented \n * for extending and developing on top of the base library.\n */\n\n/**\n * GPG4Browsers Core interface. A single instance is hold\n * from the beginning. To use this library call \"openpgp.init()\"\n * @alias openpgp\n * @class\n * @classdesc Main Openpgp.js class. Use this to initiate and make all calls to this library.\n */\nfunction _openpgp () {\n\tthis.tostring = \"\";\n\t\n\t/**\n\t * initializes the library:\n\t * - reading the keyring from local storage\n\t * - reading the config from local storage\n\t * @return [void]\n\t */\n\tfunction init() {\n\t\tthis.config = new openpgp_config();\n\t\tthis.config.read();\n\t\tthis.keyring = new openpgp_keyring();\n\t\tthis.keyring.init();\n\t}\n\t\n\t/**\n\t * reads several publicKey objects from a ascii armored\n\t * representation an returns openpgp_msg_publickey packets\n\t * @param {String} armoredText OpenPGP armored text containing\n\t * the public key(s)\n\t * @return {Array[openpgp_msg_publickey]} on error the function\n\t * returns null\n\t */\n\tfunction read_publicKey(armoredText) {\n\t\tvar mypos = 0;\n\t\tvar publicKeys = new Array();\n\t\tvar publicKeyCount = 0;\n\t\tvar input = openpgp_encoding_deArmor(armoredText.replace(/\\r/g,'')).openpgp;\n\t\tvar l = input.length;\n\t\twhile (mypos != input.length) {\n\t\t\tvar first_packet = openpgp_packet.read_packet(input, mypos, l);\n\t\t\t// public key parser\n\t\t\tif (input[mypos].charCodeAt() == 0x99 || first_packet.tagType == 6) {\n\t\t\t\tpublicKeys[publicKeyCount] = new openpgp_msg_publickey();\t\t\t\t\n\t\t\t\tpublicKeys[publicKeyCount].header = input.substring(mypos,mypos+3);\n\t\t\t\tif (input[mypos].charCodeAt() == 0x99) {\n\t\t\t\t\t// parse the length and read a tag6 packet\n\t\t\t\t\tmypos++;\n\t\t\t\t\tvar l = (input[mypos++].charCodeAt() << 8)\n\t\t\t\t\t\t\t| input[mypos++].charCodeAt();\n\t\t\t\t\tpublicKeys[publicKeyCount].publicKeyPacket = new openpgp_packet_keymaterial();\n\t\t\t\t\tpublicKeys[publicKeyCount].publicKeyPacket.header = publicKeys[publicKeyCount].header;\n\t\t\t\t\tpublicKeys[publicKeyCount].publicKeyPacket.read_tag6(input, mypos, l);\n\t\t\t\t\tmypos += publicKeys[publicKeyCount].publicKeyPacket.packetLength;\n\t\t\t\t\tmypos += publicKeys[publicKeyCount].read_nodes(publicKeys[publicKeyCount].publicKeyPacket, input, mypos, (input.length - mypos));\n\t\t\t\t} else {\n\t\t\t\t\tpublicKeys[publicKeyCount] = new openpgp_msg_publickey();\n\t\t\t\t\tpublicKeys[publicKeyCount].publicKeyPacket = first_packet;\n\t\t\t\t\tmypos += first_packet.headerLength+first_packet.packetLength;\n\t\t\t\t\tmypos += publicKeys[publicKeyCount].read_nodes(first_packet, input, mypos, input.length -mypos);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tutil.print_error(\"no public key found!\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tpublicKeys[publicKeyCount].data = input.substring(0,mypos);\n\t\t\tpublicKeyCount++;\n\t\t}\n\t\treturn publicKeys;\n\t}\n\t\n\t/**\n\t * reads several privateKey objects from a ascii armored\n\t * representation an returns openpgp_msg_privatekey objects\n\t * @param {String} armoredText OpenPGP armored text containing\n\t * the private key(s)\n\t * @return {Array[openpgp_msg_privatekey]} on error the function\n\t * returns null\n\t */\n\tfunction read_privateKey(armoredText) {\n\t\tvar privateKeys = new Array();\n\t\tvar privateKeyCount = 0;\n\t\tvar mypos = 0;\n\t\tvar input = openpgp_encoding_deArmor(armoredText.replace(/\\r/g,'')).openpgp;\n\t\tvar l = input.length;\n\t\twhile (mypos != input.length) {\n\t\t\tvar first_packet = openpgp_packet.read_packet(input, mypos, l);\n\t\t\tif (first_packet.tagType == 5) {\n\t\t\t\tprivateKeys[privateKeys.length] = new openpgp_msg_privatekey();\n\t\t\t\tmypos += first_packet.headerLength+first_packet.packetLength;\n\t\t\t\tmypos += privateKeys[privateKeyCount].read_nodes(first_packet, input, mypos, l);\n\t\t\t// other blocks\t            \n\t\t\t} else {\n\t\t\t\tutil.print_error('no block packet found!');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tprivateKeys[privateKeyCount].data = input.substring(0,mypos);\n\t\t\tprivateKeyCount++;\n\t\t}\n\t\treturn privateKeys;\t\t\n\t}\n\n\t/**\n\t * reads message packets out of an OpenPGP armored text and\n\t * returns an array of message objects\n\t * @param {String} armoredText text to be parsed\n\t * @return {Array[openpgp_msg_message]} on error the function\n\t * returns null\n\t */\n\tfunction read_message(armoredText) {\n\t\tvar dearmored;\n\t\ttry{\n    \t\tdearmored = openpgp_encoding_deArmor(armoredText.replace(/\\r/g,''));\n\t\t}\n\t\tcatch(e){\n    \t\tutil.print_error('no message found!');\n    \t\treturn null;\n\t\t}\n\t\treturn read_messages_dearmored(dearmored);\n\t\t}\n\t\t\n\tfunction read_messages_dearmored(input){\n\t\tvar messageString = input.openpgp;\n\t\tvar messages = new Array();\n\t\tvar messageCount = 0;\n\t\tvar mypos = 0;\n\t\tvar l = messageString.length;\n\t\twhile (mypos < messageString.length) {\n\t\t\tvar first_packet = openpgp_packet.read_packet(messageString, mypos, l);\n\t\t\tif (!first_packet) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// public key parser (definition from the standard:)\n\t\t\t// OpenPGP Message      :- Encrypted Message | Signed Message |\n\t\t\t//                         Compressed Message | Literal Message.\n\t\t\t// Compressed Message   :- Compressed Data Packet.\n\t\t\t// \n\t\t\t// Literal Message      :- Literal Data Packet.\n\t\t\t// \n\t\t\t// ESK                  :- Public-Key Encrypted Session Key Packet |\n\t\t\t//                         Symmetric-Key Encrypted Session Key Packet.\n\t\t\t// \n\t\t\t// ESK Sequence         :- ESK | ESK Sequence, ESK.\n\t\t\t// \n\t\t\t// Encrypted Data       :- Symmetrically Encrypted Data Packet |\n\t\t\t//                         Symmetrically Encrypted Integrity Protected Data Packet\n\t\t\t// \n\t\t\t// Encrypted Message    :- Encrypted Data | ESK Sequence, Encrypted Data.\n\t\t\t// \n\t\t\t// One-Pass Signed Message :- One-Pass Signature Packet,\n\t\t\t//                         OpenPGP Message, Corresponding Signature Packet.\n\n\t\t\t// Signed Message       :- Signature Packet, OpenPGP Message |\n\t\t\t//                         One-Pass Signed Message.\n\t\t\tif (first_packet.tagType ==  1 ||\n\t\t\t    (first_packet.tagType == 2 && first_packet.signatureType < 16) ||\n\t\t\t     first_packet.tagType ==  3 ||\n\t\t\t     first_packet.tagType ==  4 ||\n\t\t\t\t first_packet.tagType ==  8 ||\n\t\t\t\t first_packet.tagType ==  9 ||\n\t\t\t\t first_packet.tagType == 10 ||\n\t\t\t\t first_packet.tagType == 11 ||\n\t\t\t\t first_packet.tagType == 18 ||\n\t\t\t\t first_packet.tagType == 19) {\n\t\t\t\tmessages[messages.length] = new openpgp_msg_message();\n\t\t\t\tmessages[messageCount].messagePacket = first_packet;\n\t\t\t\tmessages[messageCount].type = input.type;\n\t\t\t\t// Encrypted Message\n\t\t\t\tif (first_packet.tagType == 9 ||\n\t\t\t\t    first_packet.tagType == 1 ||\n\t\t\t\t    first_packet.tagType == 3 ||\n\t\t\t\t    first_packet.tagType == 18) {\n\t\t\t\t\tif (first_packet.tagType == 9) {\n\t\t\t\t\t\tutil.print_error(\"unexpected openpgp packet\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (first_packet.tagType == 1) {\n\t\t\t\t\t\tutil.print_debug(\"session key found:\\n \"+first_packet.toString());\n\t\t\t\t\t\tvar issessionkey = true;\n\t\t\t\t\t\tmessages[messageCount].sessionKeys = new Array();\n\t\t\t\t\t\tvar sessionKeyCount = 0;\n\t\t\t\t\t\twhile (issessionkey) {\n\t\t\t\t\t\t\tmessages[messageCount].sessionKeys[sessionKeyCount] = first_packet;\n\t\t\t\t\t\t\tmypos += first_packet.packetLength + first_packet.headerLength;\n\t\t\t\t\t\t\tl -= (first_packet.packetLength + first_packet.headerLength);\n\t\t\t\t\t\t\tfirst_packet = openpgp_packet.read_packet(messageString, mypos, l);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (first_packet.tagType != 1 && first_packet.tagType != 3)\n\t\t\t\t\t\t\t\tissessionkey = false;\n\t\t\t\t\t\t\tsessionKeyCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (first_packet.tagType == 18 || first_packet.tagType == 9) {\n\t\t\t\t\t\t\tutil.print_debug(\"encrypted data found:\\n \"+first_packet.toString());\n\t\t\t\t\t\t\tmessages[messageCount].encryptedData = first_packet;\n\t\t\t\t\t\t\tmypos += first_packet.packetLength+first_packet.headerLength;\n\t\t\t\t\t\t\tl -= (first_packet.packetLength+first_packet.headerLength);\n\t\t\t\t\t\t\tmessageCount++;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tutil.print_debug(\"something is wrong: \"+first_packet.tagType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else if (first_packet.tagType == 18) {\n\t\t\t\t\t\tutil.print_debug(\"symmetric encrypted data\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else \n\t\t\t\t\t// Signed Message\n\t\t\t\t\tif (first_packet.tagType == 2 && first_packet.signatureType < 3) {\n\t\t\t\t\t\tmessages[messageCount].text = input.text;\n\t\t\t\t\t\tmessages[messageCount].signature = first_packet;\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else \n\t\t\t\t\t// Signed Message\n\t\t\t\t\tif (first_packet.tagType == 4) {\n\t\t\t\t\t\t//TODO: Implement check\n\t\t\t\t\t\tmypos += first_packet.packetLength + first_packet.headerLength;\n\t\t\t\t\t\tl -= (first_packet.packetLength + first_packet.headerLength);\n\t\t\t\t} else \n\t\t\t\t\t// Compressed Message\n\t\t\t\t\t// TODO: needs to be implemented. From a security perspective: this message is plaintext anyway.\n\t\t\t\t\t// This has been implemented as part of processing. Check openpgp.packet.\n\t\t\t\t\tif (first_packet.tagType == 8) {\n\t\t\t\t\t\tutil.print_error(\"A directly compressed message is currently not supported\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\t// Marker Packet (Obsolete Literal Packet) (Tag 10)\n\t\t\t\t\t// \"Such a packet MUST be ignored when received.\" see http://tools.ietf.org/html/rfc4880#section-5.8\n\t\t\t\t\tif (first_packet.tagType == 10) {\n\t\t\t\t\t\t// reset messages\n\t\t\t\t\t\tmessages.length = 0;\n\t\t\t\t\t\t// continue with next packet\n\t\t\t\t\t\tmypos += first_packet.packetLength + first_packet.headerLength;\n\t\t\t\t\t\tl -= (first_packet.packetLength + first_packet.headerLength);\n\t\t\t\t} else \n\t\t\t\t\tif (first_packet.tagType == 11) {\n\t\t\t\t\t// Literal Message -- work is already done in read_packet\n\t\t\t\t\tmypos += first_packet.packetLength + first_packet.headerLength;\n\t\t\t\t\tl -= (first_packet.packetLength + first_packet.headerLength);\n\t\t\t\t\tmessages[messageCount].data = first_packet.data;\n\t\t\t\t\tmessageCount++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tutil.print_error('no message found!');\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn messages;\n\t}\n\t\n\t/**\n\t * creates a binary string representation of an encrypted and signed message.\n\t * The message will be encrypted with the public keys specified and signed\n\t * with the specified private key.\n\t * @param {obj: [openpgp_msg_privatekey]} privatekey private key to be used to sign the message\n\t * @param {Array {obj: [openpgp_msg_publickey]}} publickeys  public keys to be used to encrypt the message \n\t * @param {String} messagetext message text to encrypt and sign\n\t * @return {String} a binary string representation of the message which can be OpenPGP armored\n\t */\n\tfunction write_signed_and_encrypted_message(privatekey, publickeys, messagetext) {\n\t\tvar result = \"\";\n\t\tvar literal = new openpgp_packet_literaldata().write_packet(messagetext.replace(/\\r\\n/g,\"\\n\").replace(/\\n/g,\"\\r\\n\"));\n\t\tutil.print_debug_hexstr_dump(\"literal_packet: |\"+literal+\"|\\n\",literal);\n\t\tfor (var i = 0; i < publickeys.length; i++) {\n\t\t\tvar onepasssignature = new openpgp_packet_onepasssignature();\n\t\t\tvar onepasssigstr = \"\";\n\t\t\tif (i == 0)\n\t\t\t\tonepasssigstr = onepasssignature.write_packet(1, openpgp.config.config.prefer_hash_algorithm,  privatekey, false);\n\t\t\telse\n\t\t\t\tonepasssigstr = onepasssignature.write_packet(1, openpgp.config.config.prefer_hash_algorithm,  privatekey, false);\n\t\t\tutil.print_debug_hexstr_dump(\"onepasssigstr: |\"+onepasssigstr+\"|\\n\",onepasssigstr);\n\t\t\tvar datasignature = new openpgp_packet_signature().write_message_signature(1, messagetext.replace(/\\r\\n/g,\"\\n\").replace(/\\n/g,\"\\r\\n\"), privatekey);\n\t\t\tutil.print_debug_hexstr_dump(\"datasignature: |\"+datasignature.openpgp+\"|\\n\",datasignature.openpgp);\n\t\t\tif (i == 0) {\n\t\t\t\tresult = onepasssigstr+literal+datasignature.openpgp;\n\t\t\t} else {\n\t\t\t\tresult = onepasssigstr+result+datasignature.openpgp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tutil.print_debug_hexstr_dump(\"signed packet: |\"+result+\"|\\n\",result);\n\t\t// signatures done.. now encryption\n\t\tvar sessionkey = openpgp_crypto_generateSessionKey(openpgp.config.config.encryption_cipher); \n\t\tvar result2 = \"\";\n\t\t\n\t\t// creating session keys for each recipient\n\t\tfor (var i = 0; i < publickeys.length; i++) {\n\t\t\tvar pkey = publickeys[i].getEncryptionKey();\n\t\t\tif (pkey == null) {\n\t\t\t\tutil.print_error(\"no encryption key found! Key is for signing only.\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresult2 += new openpgp_packet_encryptedsessionkey().\n\t\t\t\t\twrite_pub_key_packet(\n\t\t\t\t\t\tpkey.getKeyId(),\n\t\t\t\t\t\tpkey.MPIs,\n\t\t\t\t\t\tpkey.publicKeyAlgorithm,\n\t\t\t\t\t\topenpgp.config.config.encryption_cipher,\n\t\t\t\t\t\tsessionkey);\n\t\t}\n\t\tif (openpgp.config.config.integrity_protect) {\n\t\t\tresult2 += new openpgp_packet_encryptedintegrityprotecteddata().write_packet(openpgp.config.config.encryption_cipher, sessionkey, result);\n\t\t} else {\n\t\t\tresult2 += new openpgp_packet_encrypteddata().write_packet(openpgp.config.config.encryption_cipher, sessionkey, result);\n\t\t}\n\t\treturn openpgp_encoding_armor(3,result2,null,null);\n\t}\n\t/**\n\t * creates a binary string representation of an encrypted message.\n\t * The message will be encrypted with the public keys specified \n\t * @param {Array {obj: [openpgp_msg_publickey]}} publickeys public\n\t * keys to be used to encrypt the message \n\t * @param {String} messagetext message text to encrypt\n\t * @return {String} a binary string representation of the message\n\t * which can be OpenPGP armored\n\t */\n\tfunction write_encrypted_message(publickeys, messagetext) {\n\t\tvar result = \"\";\n\t\tvar literal = new openpgp_packet_literaldata().write_packet(messagetext.replace(/\\r\\n/g,\"\\n\").replace(/\\n/g,\"\\r\\n\"));\n\t\tutil.print_debug_hexstr_dump(\"literal_packet: |\"+literal+\"|\\n\",literal);\n\t\tresult = literal;\n\t\t\n\t\t// signatures done.. now encryption\n\t\tvar sessionkey = openpgp_crypto_generateSessionKey(openpgp.config.config.encryption_cipher); \n\t\tvar result2 = \"\";\n\t\t\n\t\t// creating session keys for each recipient\n\t\tfor (var i = 0; i < publickeys.length; i++) {\n\t\t\tvar pkey = publickeys[i].getEncryptionKey();\n\t\t\tif (pkey == null) {\n\t\t\t\tutil.print_error(\"no encryption key found! Key is for signing only.\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresult2 += new openpgp_packet_encryptedsessionkey().\n\t\t\t\t\twrite_pub_key_packet(\n\t\t\t\t\t\tpkey.getKeyId(),\n\t\t\t\t\t\tpkey.MPIs,\n\t\t\t\t\t\tpkey.publicKeyAlgorithm,\n\t\t\t\t\t\topenpgp.config.config.encryption_cipher,\n\t\t\t\t\t\tsessionkey);\n\t\t}\n\t\tif (openpgp.config.config.integrity_protect) {\n\t\t\tresult2 += new openpgp_packet_encryptedintegrityprotecteddata().write_packet(openpgp.config.config.encryption_cipher, sessionkey, result);\n\t\t} else {\n\t\t\tresult2 += new openpgp_packet_encrypteddata().write_packet(openpgp.config.config.encryption_cipher, sessionkey, result);\n\t\t}\n\t\treturn openpgp_encoding_armor(3,result2,null,null);\n\t}\n\t\n\t/**\n\t * creates a binary string representation a signed message.\n\t * The message will be signed with the specified private key.\n\t * @param {obj: [openpgp_msg_privatekey]} privatekey private\n\t * key to be used to sign the message \n\t * @param {String} messagetext message text to sign\n\t * @return {Object: text [String]}, openpgp: {String} a binary\n\t *  string representation of the message which can be OpenPGP\n\t *   armored(openpgp) and a text representation of the message (text). This can be directly used to OpenPGP armor the message\n\t */\n\tfunction write_signed_message(privatekey, messagetext) {\n\t\tvar sig = new openpgp_packet_signature().write_message_signature(1, messagetext.replace(/\\r\\n/g,\"\\n\").replace(/\\n/,\"\\r\\n\"), privatekey);\n\t\tvar result = {text: messagetext.replace(/\\r\\n/g,\"\\n\").replace(/\\n/,\"\\r\\n\"), openpgp: sig.openpgp, hash: sig.hash};\n\t\treturn openpgp_encoding_armor(2,result, null, null)\n\t}\n\t\n\t/**\n\t * generates a new key pair for openpgp. Beta stage. Currently only supports RSA keys, and no subkeys.\n\t * @param {int} keyType to indicate what type of key to make. RSA is 1. Follows algorithms outlined in OpenPGP.\n\t * @param {int} numBits number of bits for the key creation. (should be 1024+, generally)\n\t * @param {string} userId assumes already in form of \"User Name <username@email.com>\"\n\t * @return {privateKey: [openpgp_msg_privatekey], privateKeyArmored: [string], publicKeyArmored: [string]}\n\t */\n\tfunction generate_key_pair(keyType, numBits, userId, passphrase){\n\t\tvar userIdPacket = new openpgp_packet_userid();\n\t\tvar userIdString = userIdPacket.write_packet(userId);\n\t\t\n\t\tvar keyPair = openpgp_crypto_generateKeyPair(keyType,numBits, passphrase, openpgp.config.config.prefer_hash_algorithm, 3);\n\t\tvar privKeyString = keyPair.privateKey;\n\t\tvar privKeyPacket = new openpgp_packet_keymaterial().read_priv_key(privKeyString.string,3,privKeyString.string.length);\n\t\tif(!privKeyPacket.decryptSecretMPIs(passphrase))\n\t\t    util.print_error('Issue creating key. Unable to read resulting private key');\n\t\tvar privKey = new openpgp_msg_privatekey();\n\t\tprivKey.privateKeyPacket = privKeyPacket;\n\t\tprivKey.getPreferredSignatureHashAlgorithm = function(){return openpgp.config.config.prefer_hash_algorithm};//need to override this to solve catch 22 to generate signature. 8 is value for SHA256\n\t\t\n\t\tvar publicKeyString = privKey.privateKeyPacket.publicKey.data;\n\t\tvar hashData = String.fromCharCode(0x99)+ String.fromCharCode(((publicKeyString.length) >> 8) & 0xFF) \n\t\t\t+ String.fromCharCode((publicKeyString.length) & 0xFF) +publicKeyString+String.fromCharCode(0xB4) +\n\t\t\tString.fromCharCode((userId.length) >> 24) +String.fromCharCode(((userId.length) >> 16) & 0xFF) \n\t\t\t+ String.fromCharCode(((userId.length) >> 8) & 0xFF) + String.fromCharCode((userId.length) & 0xFF) + userId\n\t\tvar signature = new openpgp_packet_signature();\n\t\tsignature = signature.write_message_signature(16,hashData, privKey);\n\t\tvar publicArmored = openpgp_encoding_armor(4, keyPair.publicKey.string + userIdString + signature.openpgp );\n\n\t\tvar privArmored = openpgp_encoding_armor(5,privKeyString.string+userIdString+signature.openpgp);\n\t\t\n\t\treturn {privateKey : privKey, privateKeyArmored: privArmored, publicKeyArmored: publicArmored}\n\t}\n\t\n\tthis.generate_key_pair = generate_key_pair;\n\tthis.write_signed_message = write_signed_message; \n\tthis.write_signed_and_encrypted_message = write_signed_and_encrypted_message;\n\tthis.write_encrypted_message = write_encrypted_message;\n\tthis.read_message = read_message;\n\tthis.read_messages_dearmored = read_messages_dearmored;\n\tthis.read_publicKey = read_publicKey;\n\tthis.read_privateKey = read_privateKey;\n\tthis.init = init;\n}\n\nvar openpgp = new _openpgp();\n\n\n"]],"start1":0,"start2":0,"length1":0,"length2":18791}]],"length":18791}
